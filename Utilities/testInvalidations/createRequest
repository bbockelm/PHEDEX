#!/usr/bin/env perl
##H
##H Usage:
##H   createRequest -db FILE[:SECTION]
##H
use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/../../perl_lib";
use Data::Dumper;

use Getopt::Long;

use PHEDEX::Core::Help;

use PHEDEX::Core::DB;
use PHEDEX::Core::Identity;
use PHEDEX::RequestAllocator::Core;
use PHEDEX::RequestAllocator::SQL;
use PHEDEX::Core::SQL;
use PHEDEX::Core::Timing;
use PHEDEX::Core::XML;

#die "EXITHERE\n";
my ($conn, $dbh, $db);

&GetOptions ("db=s"        => \$db,
	     "help|h"      => sub { &usage() });

# Require  db argument:
if (@ARGV || !$db)
{
    die "DB parameter is missing. Use -h for help.\n";
}

# Connection is actually a parent class for the SQL objects:

$conn =  { DBCONFIG => $db };
bless $conn;

# Define all required parameters for the request: 

my $now = &mytimeofday();

my %h = (
   NOW  => $now,
   TYPE => 'invalidate',
   CLIENT_ID => 9,
   INSTANCE => 'natalia',
   #LEVEL => 'BLOCK',
   #COMMENTS => 'this is a test request by Nicolo'
);

#my %h = (CLIENT_ID => 9, TYPE => 'invalidation', INSTANCE => 'nicolo', LEVEL => 'BLOCK', COMMENTS => 'this is a test request by Nicolo', NOW => $now);

# Provide empty data and nodes arrayref for now: 
my $data;
$data->{FORMAT} = 'flat';
my $nodes = [];  


# Validate the parameters 
# the function signature is: 
# sub validateRequest
# {
#     my ($self, $data, $nodes, %h) = @_;
#  ... 
# }
# TODO: extend the validation function as needed according to the policies 
#
my @valid_args = &PHEDEX::RequestAllocator::Core::validateRequest($conn, $data, $nodes, %h);


#my $rid = &PHEDEX::RequestAllocator::Core::createRequest($conn);
#my $rid = &PHEDEX::RequestAllocator::Core::createRequest();

1;
